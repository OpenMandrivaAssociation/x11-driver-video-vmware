From 53e87117bbf1cba05a5b5046db9efa961b18fc74 Mon Sep 17 00:00:00 2001
From: Thomas Hellstrom <thellstrom@vmware.com>
Date: Fri, 23 Nov 2018 09:30:42 +0100
Subject: [PATCH 4/6] vmwgfx: Use libdrm to obtain the drm device node name v2

We were relying on a linux-specific way to do this. Now that the code is
used also on FreeBSD and there is functionality in libdrm to do this,
Use that functionality.

v2:
Remove unused variable warning in the !VMWGFX_LIBDRM_DEVICENAME case.

Co-authored-by: Johannes Lundberg <johalun0@gmail.com>
Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
Reviewed-by: Deepak Rawat <drawat@vmware.com> #v1
---
 configure.ac           | 10 ++++++++++
 vmwgfx/vmwgfx_dri2.c   | 43 ++++++++++++++++++++++++++++++------------
 vmwgfx/vmwgfx_driver.h | 10 ++++++++++
 3 files changed, 51 insertions(+), 12 deletions(-)

diff --git a/configure.ac b/configure.ac
index 194449a..61b7938 100644
--- a/configure.ac
+++ b/configure.ac
@@ -132,6 +132,16 @@ if test x$BUILD_VMWGFX = xyes; then
 	PKG_CHECK_EXISTS([libdrm >= 2.4.38],
 			 [AC_DEFINE([HAVE_LIBDRM_2_4_38], 1,
 			 [Has version 2.4.38 or greater of libdrm])])
+#
+# Check for drmGetDeviceNameFromFd2. On linux we need
+# 2.4.96 for compatibility with the standalone vmwgfx driver
+#
+	PKG_CHECK_EXISTS([libdrm >= 2.4.74],
+			 [AC_DEFINE([HAVE_LIBDRM_2_4_74], 1,
+			 [Has version 2.4.74 or greater of libdrm])])
+	PKG_CHECK_EXISTS([libdrm >= 2.4.96],
+			 [AC_DEFINE([HAVE_LIBDRM_2_4_96], 1,
+			 [Has version 2.4.96 or greater of libdrm])])
 fi
 
 DRIVER_NAME=vmware
diff --git a/vmwgfx/vmwgfx_dri2.c b/vmwgfx/vmwgfx_dri2.c
index bb66aef..8e04f6c 100644
--- a/vmwgfx/vmwgfx_dri2.c
+++ b/vmwgfx/vmwgfx_dri2.c
@@ -413,8 +413,6 @@ xorg_dri2_init(ScreenPtr pScreen)
     modesettingPtr ms = modesettingPTR(pScrn);
     DRI2InfoRec dri2info;
     int major, minor;
-    char fdPath[VMWGFX_FD_PATH_LEN];
-    ssize_t numChar;
 
     memset(&dri2info, 0, sizeof(dri2info));
 
@@ -430,20 +428,34 @@ xorg_dri2_init(ScreenPtr pScreen)
     dri2info.fd = ms->fd;
     dri2info.driverName = "vmwgfx";
 
-    /*
-     * This way of obtaining the DRM device name is a bit
-     * os-specific. It would be better to obtain it from
-     * drmOpen. Currently this works only for Linux.
-     */
-    memset(fdPath, 0, VMWGFX_FD_PATH_LEN);
-    snprintf(fdPath, VMWGFX_FD_PATH_LEN - 1, "/proc/self/fd/%d", ms->fd);
-    numChar = readlink(fdPath, ms->dri2_device_name, VMWGFX_DRI_DEVICE_LEN);
-    if (numChar <= 0 || numChar >= VMWGFX_DRI_DEVICE_LEN) {
+#ifdef VMWGFX_LIBDRM_DEVICENAME
+    ms->dri2_device_name = drmGetDeviceNameFromFd2(ms->fd);
+
+    if (!ms->dri2_device_name) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "Could not find the drm device name. Disabling dri2.\n");
 	return FALSE;
     }
-    ms->dri2_device_name[numChar] = 0;
+#else
+    /*
+     * This way of obtaining the DRM device name is a bit
+     * os-specific. Currently this works only for Linux.
+     */
+    {
+	char fdPath[VMWGFX_FD_PATH_LEN];
+	ssize_t numChar;
+
+	memset(fdPath, 0, VMWGFX_FD_PATH_LEN);
+	snprintf(fdPath, VMWGFX_FD_PATH_LEN - 1, "/proc/self/fd/%d", ms->fd);
+	numChar = readlink(fdPath, ms->dri2_device_name, VMWGFX_DRI_DEVICE_LEN);
+	if (numChar <= 0 || numChar >= VMWGFX_DRI_DEVICE_LEN) {
+	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+		       "Could not find the drm device name. Disabling dri2.\n");
+	    return FALSE;
+	}
+	ms->dri2_device_name[numChar] = 0;
+    }
+#endif
     dri2info.deviceName = ms->dri2_device_name;
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 	       "Path of drm device is \"%s\".\n", ms->dri2_device_name);
@@ -473,6 +485,13 @@ xorg_dri2_init(ScreenPtr pScreen)
 void
 xorg_dri2_close(ScreenPtr pScreen)
 {
+#ifdef VMWGFX_LIBDRM_DEVICENAME
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    modesettingPtr ms = modesettingPTR(pScrn);
+
+    free(ms->dri2_device_name);
+#endif
+
     DRI2CloseScreen(pScreen);
 }
 
diff --git a/vmwgfx/vmwgfx_driver.h b/vmwgfx/vmwgfx_driver.h
index cfd2ed2..fa8e308 100644
--- a/vmwgfx/vmwgfx_driver.h
+++ b/vmwgfx/vmwgfx_driver.h
@@ -71,6 +71,12 @@
 
 #define VMWGFX_DRI_DEVICE_LEN 80
 
+#undef VMWGFX_LIBDRM_DEVICENAME
+#if defined(HAVE_LIBDRM_2_4_96) || \
+  (defined(HAVE_LIBDRM_2_4_74) && !defined(__linux__))
+#define VMWGFX_LIBDRM_DEVICENAME
+#endif
+
 typedef struct
 {
     int lastInstance;
@@ -145,8 +151,12 @@ typedef struct _modesettingRec
     struct vmwgfx_hosted *hosted;
 #ifdef DRI2
     Bool dri2_available;
+#ifdef VMWGFX_LIBDRM_DEVICENAME
+    char *dri2_device_name;
+#else
     char dri2_device_name[VMWGFX_DRI_DEVICE_LEN];
 #endif
+#endif
 #ifdef HAVE_LIBUDEV
     struct udev_monitor *uevent_monitor;
     InputHandlerProc uevent_handler;
-- 
2.20.1

